---
title: "Case Study 1: Indoor Positioning System"
author: "Pankaj Kumar, Brady Arendale, Kay Ayala"
date: "5/14/2020"
output: html_document
---

```{r , include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Introduction 

We want to know if it is possible to accurately determine position on the floor of a building using a mobile device to measure signal strength from various access points. Researchers at the University of Mannheim created a dataset for this purpose. The dataset was created by standing at certain locations, holding a device at certain orientations, and repeatedly measuring signal strength to several access points. The floor plan is shown below [1]:

![Floor layout](data/layout.png)

There are a total of 166 locations, spaced one meter apart. The researchers held the device at 8 different orientations, in increments of 45 degrees. For each combination of location and orientation, the researchers recorded 110 measurements to each of 6 access points.

# Data Preparation

In order to start training models to predict location of a device, first we needed to get our data into a usable form. We first read the entire `offline.final.trace.txt` file into a character variable called `txt`.

```{r warning=FALSE}
source("case_study_functions.R", echo = T, prompt.echo = "", spaced = F)
offline_file_path = "data/offline.final.trace.txt"
txt = readLines(offline_file_path)
length(txt)
```

We have 151392 total lines in our `txt` variable. The first few lines look like this:

```{r}
txt[1:4]
```

We now see that there are lines beginning in # that do not contain actual data, so we will discard them. Additionally, each record is all on one line in a format that we will have to parse. We split each line at the euqal signs, semicolons, and commas and picked out the data by position. Since each line contained information about the device as well as the access points, we opted to store each device-access point combination as its own line. To do this, we replicated the device information (time, MAC address, position) and appended it to the information about each access point. We repeated this process for each line and combined them all into one data frame with appropriate column names. Since all our variables were still characters, we converted numerical variables to the numeric class and our time variable to the POSIXct class, after converting time from milliseconds to seconds.

We found that the type column contained both adhoc devices and access point devices. Since we only planned to use signal strengths from access points in our model, we discarded records of adhoc devices and deleted the type column. We found that scanMac and posZ only had one unique value each, and deleted those columns too. We found that there were angle values that were not exact multiples of 45 as expected. We rounded angle to the nearest 45 degrees to account for this, also setting values of 360 to be 0 since they are equivalent. We found that there were more access point MAC addresses than expected. Upon further inspection, it appeared that some access points were outside of the floor plan (possibly on other floors) since they had far fewer observations than expected, and these were removed. There also appeared to be two MAC addresses ending in c0 and cd in the same location, i.e., for the same access point. We left both of these in and will examine this in a later section. Lastly, we found there was a one-to-one correspondence between MAC address and channel, so we removed the channel column. All of this data preparation is handled by the function `readData`, which can be found in `case_study_functions.R`.

```{r}
offline = readData(offline_file_path)
```

We have many measurements of signal strength for each combination of location, orientation, and MAC address. Since we intended to use a k-nearest neighbor method to predict position of a new record of measurements, we thought measurments at the same position would take up most or all of each "neighborhood", causing the model to only predict locations at the training set grid points. For this reason, we decided to summarize each location-orientation-MAC combination by taking the mean, median, standard deviation, and interquartile range of signal strengths at each combination. This way, we can use the summarized positions in the training set as our neighbors rather than the individual measurements. This is handled by the function `createSummary`.

```{r}
offlineSummary = createSummary(offline)
```

We found that angle of the device has a significant impact on signal strengths to the various access points. To account for this, we will select rows in `offlineSummary` with either the same angle or the m closest angles to compare to new observations in our online test data set. We then reshape our data into a data frame where each row consists of position of the device and average signal strenghts to each of the 7 MAC addresses. This will allow us to compare vectors of signal strengths by measuring Euclidean distance between our offline records and an online record. This functionality is handled by the functions `selectTrain` and `reshapeSS`.

We take similar steps in preparing the online test data. However, each position in the online data is only measured at one angle, so we only need to group by location and MAC address when averaging signal strengths. We will use a simplified function called `createOnlineSummary` to summarize our online data.

# Modeling

We have now obtained vectors of signal strengths for both offline and online data. We will use a k-nearest neighbors approach to find the closest offline vectors to each online vector, and then take the average location of the offline records as our prediction for the location of the online record. We use Euclidean distance to determine closeness of vectors. We will use both a standard k-NN method taking the arithmetic mean and weighted k-NN method using a weighted average of locations. We use the following weight formula: $$\frac{1/d_i}{\sum_{i=1}^k 1/d_i}$$

`findNN` and `findNNWeight` find the nearest neighbors and the nearest neighbors with weights, respectively. We will calculate error by taking the average squared error between the true location and the predicted location, using the function `calcError`.

Before testing our model on our online data, we use cross-validation to find the value of k that minimizes the ASE. We train on 11 folds and test values of k from 1 to 20. This is done using the function `run_kkross_fold`.

```{r}

```

We noted before that there were two MAC addresses, ending in c0 and cd, that appeared to be in the same location. We will test models for both our standard and weighted methods excluding c0, excluding cd, and including both.

### Knn with euclidean distance

#### with both macs included 

```{r}
macs = unique(offlineSummary$mac)
 
 online = readData(online_file_path, subMacs = macs)
 online$posXY = paste(online$posX, online$posY, sep = "-")
 onlineSummary = createOnlineSummary(online)
 
  actualXY = onlineSummary[ , c("posX", "posY")]
  predicted_locations = predict_online_locations(offlineSummary,onlineSummary)
plot(predicted_locations)

  calcError(predicted_locations,actualXY )

```


#### without C0


```{r}
macs = unique(offlineSummary_without_cd$mac)
 
 online = readData(online_file_path, subMacs = macs)
 online$posXY = paste(online$posX, online$posY, sep = "-")
 onlineSummary = createOnlineSummary(online)
 
  actualXY = onlineSummary[ , c("posX", "posY")]
  predicted_locations = predict_online_locations(offlineSummary_without_c0,onlineSummary)
plot(predicted_locations)

  calcError(predicted_locations,actualXY )

```


#### without CD 


```{r}
macs = unique(offlineSummary_without_cd$mac)
 
 online = readData(online_file_path, subMacs = macs)
 online$posXY = paste(online$posX, online$posY, sep = "-")
 onlineSummary = createOnlineSummary(online)
 
  actualXY = onlineSummary[ , c("posX", "posY")]
  predicted_locations = predict_online_locations(offlineSummary_without_cd, onlineSummary)
plot(predicted_locations)
  calcError(predicted_locations,actualXY )


```


### Knn with inverse square signal strength (weighted distance formula) 

#### without cd  
```{r}
macs = unique(offlineSummary_without_c0$mac)
 
 online = readData(online_file_path, subMacs = macs)
 online$posXY = paste(online$posX, online$posY, sep = "-")
 onlineSummary = createOnlineSummary(online)
 predicted_locations= predict_online_locations_weighted(offlineSummary_without_cd, onlineSummary)
  plot(predicted_locations)
  calcError(predicted_locations,actualXY )


```

#### without C0

```{r}

 macs = unique(offlineSummary_without_c0$mac)
 
 online = readData(online_file_path, subMacs = macs)
 online$posXY = paste(online$posX, online$posY, sep = "-")
 onlineSummary = createOnlineSummary(online)
 
  actualXY = onlineSummary[ , c("posX", "posY")]
  predicted_locations= predict_online_locations_weighted(offlineSummary_without_c0, onlineSummary)
  plot(predicted_locations)

    calcError(predicted_locations,actualXY )

 
```


#### with both macs included 

```{r}
 macs = unique(offlineSummary$mac)
 
 online = readData(online_file_path, subMacs = macs)
 online$posXY = paste(online$posX, online$posY, sep = "-")
 onlineSummary = createOnlineSummary(online)
 
  actualXY = onlineSummary[ , c("posX", "posY")]
 predicted_locations= predict_online_locations_weighted(offlineSummary, onlineSummary)
  plot(predicted_locations)
  calcError(predicted_locations,actualXY )

```


## Summary 


## Appendix 


```{r setup, include=FALSE}
knitr::opts_chunk$set(
    echo = TRUE,
    comment=NA)
```

## Example





### cross validation 
 

```{r}
  k_errors_cd = run_kkross_fold(offlineSummaryData = offlineSummary_without_cd )
  k_errors_c0 = run_kkross_fold(offlineSummaryData = offlineSummary_without_c0 )
  
```



```{r}

  
    plot(k_errors_cd, type = 'l')
    
   plot(k_errors_c0, type = 'l')
    
    
```



### 5.	What is (are) the drawback(s) (if any of using this method to real-time locate an object)?

Few drawbacks we identified  strength can vary based on device (e.g. WiFi chip)
so a possible solution could be to standardize, scale, or rank signal strengths so it doesn't affect predictions too much
We also assumed that signals are independent and the presense of one device doesn;t affect other. There could be some relation between based on data and we can try to figure out possible correlation.
Euclidean distance might not be correct metric for predicting XY values.  We can use Manhattan Distance or others. 
We are using knn which is one of the simplest approach and neighbourhood based clusterning might not be most appropriate one,


### 6.	Describe a method that may be an improvement based on your perceived drawbacks.

We can use methods to handle each of the drawbacks identified above. 
Some data normalization and transformation can be done  to handle problem of varying signal strengthe of devices. 
We can also do some correlation analysis between different variable  to find any data dependence . 
Different distance functions can be used to analyse the impact of metric. We can use Manhattan Distance or others. 
We may use SVM to better classify data around more appropriate boundries and compare results with knn approach.  


 